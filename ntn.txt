5:
CODE SEGMENT
	ASSUME CS:CODE
START:
	MOV DS 4000H
	MOV DX C000H
	MOV CX 0H
AGAIN:     
	DEC DX
	INC CX
	MOV [DX] 55H
	CMP DX 0000H
	JNE AGAIN
AGAIN2:  CMP [DX] 55H
	JNE NEQUA
	INC DX
	LOOP AGAIN2
	MOV AL 7EH
	JMP EXIT
NEQUA:   MOV AL 81H
EXIT:         
CODE ENDS
	END START

6:
DATA SEGMENT
	ORG 4000H
	DATA1 DB 108 DUP(?)
	ORG A000H
	DATA2 DB 108 DUP(?)
	DATA ENDS
CODE SEGMENT
	ASSUME CS:CODE,DS:DATA
START:
	MOV SI 4000H
	MOV DI A000H
	MOV CX 128
AGAIN:     MOV DL [SI]
	MOV [DI] DL
	INC SI
	INC DI
	LOOP AGAIN
	MOV CX 128
AGAIN2:   MOV AL [SI]
	MOV BL [DI]
	CMP AL BL
	JNE WRONG
	DEC SI
	DEC DI 
	LOOP AGAIN2
	MOV BL FFH
	JUMP EXIT
WRONG:  MOV BL 00H
EXIT:         CODE ENDS
	END START

8£º

DATA SEGMENT
	LIST DB 100 DUP(?)
	NUMB DB DUP(?)
	LENGTH DB 100
DATA ENDS
CODE SEGMENT
	ASSUME CS:CODE DS:DATA
START :
	MOV AX DATA
	MOV DS AX
	MOV CX 100
	MOV AL NUMB
NEXT: 
	CMP LIST[CX] AL
	JZ EXIT
	LOOP NEXT
	MOV CX 99
	MOV DX 0
	ADD LENGTH 1
ADJT:
	MOV BL LIST[CX]
	CMP AL BL
	JL INSERT
	MOV LIST[CX][1] BL
	DEC CX
	CMP CX DX
	JGE ADJT
INSERT:
	MOV LIST[CX][1] AL
EXIT:
CODE ENDS	
	START END


12:
DATA SEGMENT
	LIST DB 80DUP(?)
	BTRX DB 5 DUP(0)
	AVER DB 0
DATA ENDS 
CODE SEGMENT
	ASSUME CS:CODE ,DS:CODE
START:
	MOV AX DATA
	MOV DS AX
	MOV CX 80
	MOV AX 0
AGAIN:
	ADD AX LIST[CX]
	CMP LIST[CX] 90
	JL EIGHT
	INC BTRX[0]
	JUMP NEXT
EIGHT:
	CMP LIST[CX] 80
	JL SEVT
	INC BTRX[1]
	JUMP NEXT
SEVT:
	CMP LIST[CX] 70
	JL SIXT
	INC BTRX[2]
	JUMP NEXT
SIXT:
	CMP LIST[CX] 60
	JL LOWSC
	INC BTRX[3]
	JUMP NEXT
LOWSC:
	INC BTRX[4]
NEXT:
	LOOP AGAIN
	MOV DL 80
	DIV DL
	MOV AVER AL
CODE ENDS
	END START